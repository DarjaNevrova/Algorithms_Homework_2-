//Alhoritms_Homework_two

// 1) Вопрос: Как оценивается эффективность алгоритма?
//    Ответ: 
//  1.1)Фактор времени - время измеряется путем подсчета кол-во ключевых операций;
//  1.2) Фактор пространства - оно измеряется путем подсчета максимального обьема памяти, требуемого алгоритмом.


// 2) Вопрос: Что учитывается при асимптотическом анализе?
//   Ответ:
// 2.1) Временная сложность: Изучается, как меняется время выполнения алгоритма по мере роста размера входных данных.
// Есть три понятия, с которыми можно столкнуться при оценке сложности.
// O (O - большое) - верхняя асимтотическая оценка роста временной функции;
// Ω (Омега) - нижняя асимптотическая оценка роста временной функции;
// Θ (Тета) - нижняя и верхняя.
// 2.2) Пространственная сложность: изучается, как меняется использование памяти алгоритмом по мере роста размера входных данных.


// 3) Вопрос: Перечислите основные правила асимптотического анализа
//   Ответ:
//   3.1) O(k * f) = O(f) - эти асимптотики равны, константа отрасывается.
//   3.2) O(f * g) = O(f)*O(g) - оценка сложности двух функций равна произведению их сложностей.
//   3.3) O(f / g) = O(f)/O(g) - оценка сложности частного двух функций равна частному их сложностей.
//   3.4) O(f + g) = O(f) и O(g) - оценка сложночти суммы функций определяется как оценка сложности доминанты первого и второго слогаемых


// 4) Вопрос: Какие порядки роста асимтотических функций знаете?
//   Ответ:
// 4.1) Константный - O(1)
// 4.2) Линейный - O(n)
// 4.3) Логарифмический - O( log n)
//      Означает, что время выполнения алгоритма растет логарифмически с увелечением размера входного массива.
//      Алгоритм имеет время выполнения, логарифмически зависящее от размера входных данных. 
// 4.4) Линейно - логарифмический - O( n log n)
//      Cортировка слиянием и быстрая сортировка, попадают также некоторые алгоритмы типа - "divide and conquer"
//  4.5) Квадратичный O (n ^ 2)
//       Зависит от квардата размера входного массива.(Bubble sort)
//  4.6) Факториальный O(n!) - очень медленный алгоритм


// 5) Вопрос: Оцените сложность по времени и памяти
// void method(int n) {
//   for (int i = 0; i < n / 2; i++) { Ответ: n/2 -> 0(n/2) = 0(n)
//       for (int j = 1; j + n / 2 <= n; j++) { Ответ: n/2 -> 0(n/2) = 0(n)
//          for (int k = 1; k <= n; k = k * 2) {
//               System.out.println("I am expert!");
//             }
//         }
//     }
// }
//   Ответ: O(n) * O(n) * O(log(n)) -> O(n^2 * log(n))
//          0(1)
//   

// 6) Вопрос: Оцените сложность по времени и памяти

// void method2(int n) {
//     for (int i = 1; i <= n; i++) { -> O(n)
//         for (int j = 1; j <= n; j = j + i) { -> O(n)
//             System.out.println("I am expert!");
//         }
//     }
// }
//   Ответ: O(n) * O(n) -> O(n ^ 2)
//          O(1)



// 7) Вопрос: Оцените сложность по времени и памяти
// void method3(int a, int b) { -> 0(max(a, b))
//     while (a != b) {
//         if (a > b) {
//             a = a - b;
//         } else {
//             b = b - a;
//         }
//     }
// }

// Ответ: 0(max(a, b))
//        O(1)

